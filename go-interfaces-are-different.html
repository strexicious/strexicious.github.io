<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Go Interfaces Are Different</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      max-width: 80ch;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
    }

    h1,
    h2 {
      font-weight: 700;
    }

    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
  </style>
</head>

<body>
<h1 id="go-interfaces-are-different">Go Interfaces Are Different</h1>
<p>Different to what? Well, compared to most other languages. Although
they are named “interfaces”, they are not to be (or rather, must not be)
used in the same manner as promoted in other languages.</p>
<h2 id="the-manners-of-other-languages">The manners of other
languages</h2>
<p>In other languages you if you want a cat to be an animal, the concept
of animal must be defined, and then definition of cat must explicitly
declare that a cat is an animal. In principle, this explicitness, sounds
like a good thing to require.</p>
<pre><code>// in some not go language
// an animal-kingdom package

interface Animal {
  ...
}

class Cat extends Animal {
  ...
}</code></pre>
<p>Before we move onto how Go interfaces are intended to be used, let’s
look at how might a user of this package use these definitions, so that
we have a point of comparison for Go.</p>
<pre><code>// in some not go language
// a pet-simulator package

void pet(Animal a) { ... }</code></pre>
<h2 id="gos-manners">Go’s manners</h2>
<p>Let’s quickly look at how the same code in Go would be separated.</p>
<pre><code>package animal_kingdom

type Cat struct {
  ...
}</code></pre>
<p>And then…</p>
<pre><code>package pet_simulator

type Animal interface {
  ...
}

func pet(Animal a) { ... }</code></pre>
<p>Do you see anything funny? (If not, take a closer look at how the
code is organised.) What’s going on?</p>
<p>So basically, in Go, the implementer of <code>pet_simulator</code>
defines the interface that it wants to use. But the implementer of
<code>pet_simulator</code> is a user of the <code>animal_kingdom</code>
package, and as such, the definition of cat can never explicitly say
that it is an animal since it does not know who the user will be a
priori.</p>
<p>To summarise: in Go the <em>user</em> of some code is suppose to
provide an abstraction for some other code, <em>not</em> the
<em>implementer</em> of that other code.</p>
<p>But then how does Go know that something like
<code>type Airplane struct { ...}</code> is not an animal? Well let’s
get a bit technical now (but I am no expert)…</p>
<h2 id="method-sets">Method sets</h2>
<p>In Go, each type has a method set. To quickly illustrate, in the
following, <code>M1</code> and <code>M2</code> are in the method set of
<code>T</code>.</p>
<pre><code>type T { ... }

func (T) M1() { ... }
func (T) M2() { ... }</code></pre>
<p>And when you define an interface in Go, you are basically defining a
method set that is not tied to any type. To give a quick example, let’s
look at a standard library interface:</p>
<pre><code>type Stringer interface {
  String() string
}</code></pre>
<p>This is a method set not associated to any type. In this case, it
just declares a method named <code>String</code> with no paramters and
return type <code>string</code>.</p>
<h2 id="how-is-airplane-not-an-animal">How is <code>Airplane</code> not
an <code>Animal</code>?</h2>
<p>Well in the previous discussion we have been ignoring the definition
of <code>Animal</code>. Suppose it looks something like this:</p>
<pre><code>type Animal interface {
  Walk(distance float64)
}</code></pre>
<p>Now, if <code>Airplane</code> has a method named <code>Walk</code>
that accepts a single <code>float64</code> and does not return anything,
then <code>Airplane</code> is considered an <code>Animal</code>
according to Go. But it is unlikely that <code>Airplane</code> has a
method named <code>Walk</code>.</p>
<p>This is how Go interfaces work. They are implicitly “attached” to
types. And so, let us consider again the <code>pet_adoption</code>
package, and examine a weird quirk of how Go intends for us to use the
interfaces. To clarify, the package looks like this with our
<code>Animal</code> interface better defined now:</p>
<pre><code>package pet_simulator

type Animal interface {
  Walk(distance float64)
}

func pet(Animal a) { ... }</code></pre>
<p>And we are going to consider another package now:</p>
<pre><code>package human_simulator

type Human struct {
  ...
}

func (h *Human) Walk(distance float64) { ... }</code></pre>
<p>And apparently now the following code is valid:
<code>pet(&amp;Human{})</code>. What the flip-flops weeb stuff is going
on here?? This is terrible! If only we could let the implementer of cat
explicitly declare itself as an animal from animal kingdom then this
would never happen! Go interfaces suck!</p>
<h2 id="hold-on-dont-jump-to-conclusions-yet">Hold on… don’t jump to
conclusions yet</h2>
<p>So what went wrong in the preceding discussion?</p>
<p>Well nothing and everything. It depends on the experiences of the
reader. The discussion up to this point has been to reel in the readers
who have been taught that software engineering is about designing
systems from top to bottom, starting with higher up abstractions that
are closer to <em>user</em>’s notions and intuitions rather than having
you focusing on the solution <em>you</em> must implement. (The people
who teach and have been taught to use UML diagrams to “engineer”
systems, for example.) But in my experience that is the wrong approach
to problem solve, and in my opinion, especially in engineering fields.
(I have tried that top-down approach many times. From Java and C++ to
Rust and Haskell.)</p>
<h2 id="problem-solving-and-go-code">Problem solving and Go code</h2>
<p>Instead of trying to explain what problem solving I am talking about,
I will just refer to George Pólya’s amazing <a
href="https://sass.queensu.ca/sites/sasswww/files/uploaded_files/Resource%20PDFs/polya.pdf">problem
solving list</a>. (One could say we are talking about pure logical,
deductive problem solving here.)</p>
<p>Particularly, the resemblence between problem solving and coding is
that solving a problem equates to implementing a function. The function
declaration (including the properties asserted in the doc comment) is a
statement of the problem. The process of implementing the function is
the process of finding the solution.</p>
<p>The paramater data types of the function are the given data for a
problem. More often than not, when you are solving a problem for the
first time, you will use concrete data, more specialised input data
forms to solve your problem. After you have solved your problem, or in
the process, you may realise that you only need specific properties of
the data, and you can solve a generic problem by generalising the data
in your problem statement, then you can obtain a generic solution.</p>
<p>To be less abstract, and finally make my point clearly, when
implementing a function, start with concrete types in parameters, and if
you find that you need only specific methods of the input data, then you
can make an interface to substitute the concrete type.</p>
<p>So how does this help with <code>pet(&amp;Human{})</code>? Well, it
does not. In Go, it is the responsibility of the caller of
<code>pet</code> to not call it with some variable for which it does not
make much sense. And I find it to be more productive to worry about
using my data correctly because it lets me focus on solving the problem
at hand, than to think about how to create a perfect world model in
which I can then restate my problem and find a nice solution. It is a
good thing to try to find an existing world model in which your problem
can solved more simply. (Basically looking for an existing library.) But
if that world model has not been implemented, just use the tools at your
disposal. And at the minimum, functions and plain-old-data types are
always there, and those are the tools that any new programmer and
software engineer is taught from the get go.</p>
  
</body>

</html>